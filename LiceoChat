#!/bin/python

"""
  -### Progress Bar ###-

   Liceo Talking Robot 

Interogative:
	who:		[#########-] 90%
	what:		[#########-] 90%
	where:	[#########-] 90%
	when:		[#########-] 90%

Non-Intergative:
	overall: 	[#######---] 70%

"""

""" START: LIBRARIES """

from datetime import datetime
from random import choice as selectRandom
from time import sleep
import spacy
import readline
import argparse
from os import system as execute
from requests import get
from weather import fetchWeather

""" END: LIBRARIES """

""" START: CLASSES """

class Colors:
	R = "\033[0m"
	BLACK = "\033[90m"
	RED = "\033[91m"
	GREEN = "\033[92m"
	YELLOW = "\033[93m"
	BLUE = "\033[94m"
	MAGENTA = "\033[95m"
	CYAN = "\033[96m"
	WHITE = "\033[97m"

""" END: CLASSES """

""" START: GLOBAL VARIABLES """

weatherAPIKey = "faea01bba46677a17a6f902bf2f3096b"
c = Colors()
chatbotSpeakFlag = True
debugging = False
chatbotReplyDelay = True
naturalLanguageProcessing = spacy.load("en_core_web_sm")

jokes = (
	"Why was the equal sign so humble? Because it knew it wasn't less than or greater than anyone else!",
	"Why don’t skeletons fight each other? They don’t have the guts.",
	"What do you call fake spaghetti? An impasta!",
	"I would tell you a construction joke, but I’m still working on it.",
	"Why can’t your nose be 12 inches long? Because then it’d be a foot!")

funny_jokes = (
	"Why don't oysters donate to charity? Because they are shellfish.",
	"I asked the librarian if the library had any books on suicide. She said they were all checked out.",
	"Why did the scarecrow win an award? Because he was outstanding in his field!",
	"How does a penguin build its house? Igloos it together.",
	"Why did the chicken join a band? Because it had the drumsticks.",
	"Why are chatbots terrible comedians? They always give the punchline away in the response!")

facts = (
	"An octopus has three hearts—two pump blood to the gills, and one pumps it to the rest of the body.",
	"Astronauts describe the smell of space as a mix of gunpowder, seared steak, and raspberries.",
	"The longest English word in a major dictionary is pneumonoultramicroscopicsilicovolcanoconiosis, a type of lung disease.",
	"Botanically, bananas are berries, but strawberries are not!",
	"Light takes about 8 minutes and 20 seconds to travel from the Sun to Earth.",
	"The word 'queue' has four silent letters—it’s just the letter 'q' with a fancy tail!")

interesting_facts = (
	"Honey never spoils—archaeologists have found pots of honey in ancient Egyptian tombs that are over 3,000 years old and still safe to eat.",
	"A day on Venus is longer than a year on Venus due to its slow rotation on its axis.",
	"Sloths can hold their breath longer than dolphins—they can slow their heart rate and stay underwater for up to 40 minutes.",
	"Sharks existed before trees—they've been around for more than 400 million years.",
	"The dot over the letters 'i' and 'j' is called a tittle.",
	"Octopuses have blue blood due to the copper-based molecule hemocyanin, which is more efficient than hemoglobin in cold, low-oxygen environments.")

cool_facts = (
	"The surface area of a human lung is roughly the same as a tennis court.",
	"Water can boil and freeze at the same time—this phenomenon is called the triple point and happens under specific pressure and temperature conditions.",
	"The shortest war in history was between Britain and Zanzibar on August 27, 1896, lasting only 38 minutes.",
	"A single strand of spider silk is thinner than a human hair but five times stronger than steel of the same diameter.",
	"There’s a species of jellyfish known as Turritopsis dohrnii that is biologically immortal—it can revert to its polyp stage and start its life cycle anew.",
	"Saturn's moon Titan has rivers, lakes, and seas of liquid methane and ethane, making it the only other place in the solar system known to have stable liquids on its surface.")

possibleResponses = {
	"m": {
		"alright": "That's good to hear! How can I help you today?",
		"good": (
	"That's great! What can I assist you with today?",
    "Glad to hear that! How may I be of service?",
    "Awesome! What do you need help with today?",
    "That's wonderful! Let me know how I can assist you.",
    "Good to know! What can I do for you?"),
	},
	"do": {
		"you": {
			"like": {
				"music": "",
				"people": "",
				"animals": ""
			},
		},
	},
	"can": {
		"you": {
			"help": {
				"me": "Of course! Is there any questions you want me to answer?"
			},
			"tell": {
				"joke": jokes,
				"fact": facts
			},
		},
	},
	"tell": {
		"joke": {
			"joke": jokes,
			"funny": funny_jokes,
		},
		"fact": {
			"fact": facts,
			"interesting": interesting_facts,
			"cool": cool_facts,
		},
	},
	"who": {
		"jun": {
			"jerome": {
				"balagot": "Jun Jerome Balagot is a robotics teacher in Liceo de Cagayan University. He is one of the most humble teacher in Liceo."
			}
		},
		"own": { 
			"liceo": "The owners of Liceo De Cagayan University are Rodolfo Pelaez and his wife Elsa Pelaez.",
			},
		"you": "I am a chatbot designed and developed by the dedicated ICT students and teachers at Liceo De Cagayan University. My main purpose is to assist you with any questions or tasks you may have, whether it's related to academic inquiries, campus information, or any other services we offer. I'm here to provide you with accurate and helpful responses, and I'm excited to help make your experience smoother and more efficient. Feel free to ask me anything, and I'll do my best to assist you!",
		"chairpersons": {
			"tvl": {
				"tvl": "The chairperson in TVL 1 is Miss Wynne Lim and the chairperson in TVL 2 is Mister Charlie Yabes.",
				"liceo": "The chairperson in TVL 1 is Miss Wynne Lim and the chairperson in TVL 2 is Mister Charlie Yabes."
			},
			"liceo": {
				"tvl": "The chairperson in TVL 1 is Miss Wynne Lim and the chairperson in TVL 2 is Mister Charlie Yabes.",
			},
		},
		"create": {
			"you": "I am created by Ever Sanaga. An ICT student in Liceo De Cagayan University."
		},
		"paint": {
			"mona": {
				"lisa": "Leonardo da Vinci painted the Mona Lisa.",
			},
		},
		"invent": {
			"light": {
				"bulb": "Thomas Edison is credited with inventing the practical light bulb."
			}
		},
		"charlie": {
			"yabes": "Charlie C. Yabes is the chairperson in TVL 2. Together with Miss Wynne Lim, they are one of the seasoned teachers in Liceo de Cagayan University.",
		},
		"wynne": {
			"lim": "Wynne Lim is the chairperson in TVL 1. Together with Mister Charlie Yabes, they are one of the experienced teachers in Liceo de Cagayan University.",
		}
	},
	"what": {
		"can": {
			"you": {
				"do": "I can answer questions and have a chat with you. Just ask!"
			}
		},
		"name":"I am LiceoChat, I'm happy to answer any questions related to Liceo De Cagayan University.",
		"liceo" : {
			"liceo": "Liceo de Cagayan University is a private, non-sectarian institution in Cagayan de Oro, Philippines, offering diverse programs with a focus on academic excellence and community development.",
			"cagayan": {
				"cagayan": "Liceo de Cagayan University is a private, non-sectarian institution in Cagayan de Oro, Philippines, offering diverse programs with a focus on academic excellence and community development.",
				"university": "Liceo de Cagayan University is a private, non-sectarian institution in Cagayan de Oro, Philippines, offering diverse programs with a focus on academic excellence and community development."
			},
			"de": {
				"cagayan": "Liceo de Cagayan University is a private, non-sectarian institution in Cagayan de Oro, Philippines, offering diverse programs with a focus on academic excellence and community development.",
			}
		},
		"time": {
			"time": datetime.now().strftime("The current time is %I:%M %p on %A."),
		},
		"weather": {
			"weather": fetchWeather(weatherAPIKey),
			"today": fetchWeather(weatherAPIKey)
		},
		"smallest": {
			"country": "Vatican City is the smallest country in the world by land area.",
			"animal": "The smallest known animal is a parasitic wasp called Dicopomorpha echmepterygis, with males measuring only about 0.139 mm in length.",
		},
		"up": "The ceiling, the sky, and my processing power! What's up with you?",
		"life": {
			"meaning": "Nice question! The meaning of life is to seek purpose, forge connections, and create value in the time we are given.",
			"answer": "For me, the answer to life is to learn, grow, and help others in meaningful ways."
		}

	},
	"where": {
		"smallest": {
			"country": "Vatican City is the smallest country in the world by land area.",
		},
		"liceo": "Oh! I know where you can find Liceo De Cagayan University. It is located at Kauswagan, Rodolfo N. Pelaez Boulevard, Cagayan De Oro City"
	},
	"when": {
		"found": {
			"liceo": "Liceo was founded in the year 1955."	
		}
	},
	"how": {
		"weather": {
			"weather": fetchWeather(weatherAPIKey),
			"today": fetchWeather(weatherAPIKey),
		},
		"you": {
			"you": (
				"I'm doing fine, how about you?",
				"I'm doing great, thanks for asking! How about yourself?",
				"I'm feeling awesome! How are you doing?",
				"I'm well, thank you. And you?"),
		},
	}
}

overloadQuestionErrorResponses = (
	"Sorry, could we please focus on one question at a time?",
	"I apologize, but can you please ask one question at a time?",
	"I'm sorry, but it's a bit difficult to answer multiple questions at once. Can we take them one by one?",
	"Sorry about that, but I'd appreciate it if we could go through one question at a time.",
	"Apologies, but I can only answer one question at a time. Could we start with the first?"
	)

inputErrorResponses = (
	"Sorry, I may have not heard what you said. Could you repeat it again?",
	"Apologies, I don't understand what you said. Can you repeat it?",
	"Sorry, I didn't catch that. Could you say it again?",
	"I'm sorry, I didn't quite understand. Could you repeat that?",
	"Sorry, I didn't follow that. Could you say it one more time?",
	"Sorry, I didn't quite hear that. Could you say it again?",
	"Apologies, I didn't catch that. Can you repeat what you said?",
	"Sorry, I didn't understand you clearly. Could you say that again?",
	"I'm sorry, I missed that. Can you repeat it for me?",
	"Sorry, I didn't quite get that. Could you repeat what you just said?",
	"Apologies, I didn't follow that. Could you say it one more time?",
	"Sorry, I didn't quite grasp what you said. Could you say it again?",
	"I'm sorry, I didn't hear you properly. Can you repeat that?",
	"Sorry, I didn't understand. Could you say that again for me?",
	"Apologies, I missed that part. Could you repeat it once more?"
)

questionErrorResponses = {
		"do": ("I apologize, I don't have any information about that topic."),
		"who": ("Sorry, I don't know who that person is.",
		"I apologize, It seems that I don't have any information connected to that person."),

		"where": ("I apologize, I have no information regarding to where that location is.",
		"I'm sorry, I don't know where that place is located."),

		"what": ("I'm sorry, I don't know what you meant.",
		"I'm sorry, I didn't understand what you said."),
	
		"when": ("I'm sorry, I don't know when that is.",
		"I apologize, I'm not sure when that happened."),

		"why": ("I honestly don't know why.",
		"I'm afraid I don't know why."),

		"how": ("I apologize, but I honestly don't know how.",
		"I'm sorry, but I wish I knew how.")
	}

greets = (
	"Hi! I am a chatbot. I can provide informations about Liceo De Cagayan University.",
	"Hello! How can I help you today? I am from Liceo De Cagayan University.",
	"Oh! Hi there! I am a chatbot made in Liceo De Cagayan University, how can I help you?",
	"Hello person! Ask me anything about Liceo De Cagayan University!",
	"Hi there! I'm here to assist you with anything about Liceo De Cagayan University.",
    "Hello! Need help? I'm your chatbot guide for Liceo De Cagayan University.",
    "Greetings! I can answer your questions about Liceo De Cagayan University. What would you like to know?",
    "Hey! I’m your friendly chatbot from Liceo De Cagayan University. How can I assist you today?",
    "Hello! Ask me anything about Liceo De Cagayan University, and I’ll do my best to help.",
    "Hi! I’m a chatbot from Liceo De Cagayan University. How can I make your day easier?",
    "Oh, hello! I specialize in everything about Liceo De Cagayan University. What do you need?",
    "Hi! Got questions about Liceo De Cagayan University? I’ve got the answers!",
    "Hello! I’m your virtual assistant from Liceo De Cagayan University. How can I be of service?",
    "Hi there! I’m ready to help you with anything related to Liceo De Cagayan University!"
	)

""" END: GLOBAL VARIABLES """

""" START: FUNCTIONS """

def printBanner() -> None:
	execute("./LiceoLogo")
	return

def clean(text: str) -> str:
	debug(f"@ clean(): {text=}")
	if text:
		if not text == "ever":
			if text[-2:] == "er":
				return text[:-2]

			elif text[-3:] == "ers":
				return text[:-3]

			elif text[-1] == "s":
				return text[:-1]

			else:
				return text

		else:
			return text
	else:
		return text

def chatbotSpeak(text: str) -> None:
	if chatbotSpeakFlag:
		toSay = text.replace("'", "")
		debug(f"@ chatbotSpeak(): {toSay=}")
		execute(f"echo \"{toSay}\" |festival --tts &")
		# execute(f"espeak -p 50 -s 140 \"{text}\" &")
		return
	return

def getFirstAdverb(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.pos_ == "ADV" and token.dep_ in ["npadvmod", "advmod"]:
			return token.text.lower()
	return ""
def getFirstAdjective(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.pos_ == "ADJ":
			return token.text.lower()
		elif token.dep_ in ["amod", "compound"] and token.pos_ in ["NOUN", "PROPN"]:
			return token.text.lower()
	return ""

def getMainVerb(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.pos_ == "VERB" and token.dep_ != "aux":
			return token.text.lower()
	return ""

def getGlobalObject(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "prep":
			for child in token.children:
				if child.dep_ == "pobj" and child.pos_ in ["NOUN", "PROPN"]:
					return child.text
		if token.dep_ in ["dobj", "attr"] and token.pos_ in ["NOUN", "PROPN"]:
			return token.text.lower()
	return ""

def getDirectObject(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "ROOT" or token.dep_ == "aux":
			for child in token.subtree:
				if child.dep_ == "dobj":
					return child.text.lower()
	return ""
	
def getDirectObjectEx(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "dobj":
			return token.text.lower()
	return ""

def getSubject(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if "subj" in token.dep_:
			return token.text.lower()
	return ""

def getObjectOfPreposition(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if "pobj" in token.dep_:
			return token.text.lower()
	return ""

def getPredicateNominative(text: str) -> list:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "ROOT" and token.lemma_ == "be":
			for child in token.children:
				debug(f"@ getPredicateNominative(): {child.text.lower()=}")
				if child.text.lower() == "ever" and child.pos_ == "ADV":
					return ["ever", "sanaga"][::-1]
				elif child.text.lower() == "ryan" and child.pos_ == "ADV":
					return ["ryan", "gaas"][::-1]
				if child.dep_ == "attr" or child.dep_ == "nsubj":
					if child.text.lower() not in ["who", "what"]:
						predicate_tokens = [child.text.lower()]
						for subchild in child.children:
							if subchild.dep_ == "compound":
								predicate_tokens.append(subchild.text.lower())
						return predicate_tokens
			for child in token.subtree:
				if child.dep_ == "nsubj" and child.text.lower() in ["who", "what"]:
					continue
				elif child.pos_ in ["NOUN", "PROPN"]:
					return [child.text.lower()]
	return ""

def getFirstPrepositionalObject(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "prep":
			for child in token.children:
				if child.dep_ == "pobj" and child.pos_ in ["NOUN", "PROPN"]:
					return child.text.lower()
	return ""

def getNestedPrepositionalObject(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	prepositional_objects = []
	for token in doc:
		if token.dep_ == "prep":
			for child in token.children:
				if child.dep_ == "pobj" and child.pos_ in ["NOUN", "PROPN"]:
					prepositional_objects.append(child.text.lower())
	return prepositional_objects[-1] if prepositional_objects else ""

def getRootVerb(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "ROOT" and token.pos_ == "VERB":
			return token.lemma_.lower()
	return ""

def getRootWord(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "ROOT":
			return token.text.lower()
	return ""

def getRootVerbIndex(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "ROOT" and token.pos_ == "VERB":
			start_index = token.idx
			end_index = start_index + len(token.text)
			return text[start_index:end_index] 
	return ""

def getProperNoun(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.pos_ == "PROPN" and not token.is_stop:
			if token.text.lower() not in ["word", "thing", "stuff", "idea"]:
				return token.text.lower()
	return ""
def getGrammaticalNumber(text: str) -> str:
	doc = naturalLanguageProcessing(text)
	for token in doc:
		if token.dep_ == "nsubj" or (token.dep_ == "nsubj" and token.pos_ == "PRON"):
			if token.tag_ in ["NN", "NNP", "PRP"]:
				return "singular"
			elif token.tag_ in ["NNS", "NNPS", "PRP$"]:
				return "plural"
		if token.dep_ == "nsubj" and token.text.lower() in ["who", "what"]:
			return "singular"   
	return ""
def debug(text: str) -> None:
	if debugging:
		logText = f"{c.RED}[DEBUG] {c.BLUE}[{datetime.now().time().strftime('%H:%M:%S')}] {c.GREEN}{text}{c.R}"
		with open("log.txt", "a") as logFile:
			print(logText)
			logFile.write(logText+"\n")
		sleep(0.008)
		return
	return
def talkBot(text: str) -> None:
	debug("@ talkBot(): executing chatbotSpeak()")
	chatbotSpeak(text)
	if chatbotReplyDelay:
		print(f"{c.CYAN}[LDCU_BOT]: {c.WHITE}", end="")
		for letter in text:
			print(letter, end='', flush=True)
			sleep(0.01)
		print(c.R)
	else:
		print(f"{c.CYAN}[LDCU_BOT]: {c.WHITE}{text}{c.R}")
	return

def introGreet() -> None:
	return selectRandom(greets)

def getInput() -> dict:
	try:
		# Update time
		possibleResponses["what"]["time"]["time"] = datetime.now().strftime("The current time is %I:%M %p on %A.")
		emotionVerbs = [
    "adore", "appreciate", "cherish", "enjoy", "favor", "love", "like", "respect", 
    "revere", "treasure", "delight", "relish", "worship", "despise", "detest", 
    "dislike", "hate"]
		interrogativeWords = ("who", "where", "what", "when", "why", "how")
		modalVerbs = ("can", "could", "may", "might", "will", "would", "shall", "should", "must", "ought")
		personalPronouns = ("i", "they")
		adverbsOfTime = ("today", "tomorrow", "yesterday", "now", "later", "soon", "tonight", "this morning", "this evening")
		# NOTE:
		# Add more type for more accuracy in recognizing text.

		inputType = {
			"isQuestion": False,
			"questionType": "",
			"interrogativeWordsCount": 0,
			"subjectWord": "",
			"subjectWordIndex": 0,
			"subjectWordName": "",
			"subjectWordNameEx": "",
			"grammaticalNumber": "",
			"rawSubjectWord": "",
			"rootWord": "",
			"globalObject": "",
			"globalObjectEx": "",
			"modalVerb": "",
			"adjectiveWord": "",
			"adjectiveWordEx": "",
			"adverbTime": "",
			"totalWords": 0,
			}

		userInput = input(f"{c.YELLOW}[LICEAN]: {c.WHITE}").title()

		if not userInput:
			return

		listUserInput = userInput.split(" ")

		debug("@ getInput(): checking userInput for a modalVerb")
		for word in modalVerbs:
			for words in listUserInput:
				if word == words.lower():
					debug(f"@ getInput(): [{word}] | [{words.lower()}]")
					inputType["modalVerb"] = word
					debug(f"@ getInput(): modalVerb found ---\\> {inputType["modalVerb"]=}")

		debug("@ getInput(): checking userInput for an interrogativeWord")
		for word in interrogativeWords:
			for words in listUserInput:
				if word == words[:len(word)].lower():
					inputType["isQuestion"] = True
					inputType["questionType"] = word
					inputType["interrogativeWordsCount"] += 1

		if not inputType["isQuestion"]:
			if listUserInput[0].lower() == "do":
				inputType["questionType"] = "do"

		debug("@ getInput(): checking userInput for an adverbTime")
		for word in adverbsOfTime:
			for words in listUserInput:
				if word == words[:len(word)].lower():
					inputType["adverbTime"] = word

		debug("@ getInput(): checking userInput for an emotionVerb")
		for word in emotionVerbs:
			for words in listUserInput:
				if word == words.lower():
					debug("@ getInput(): found an emotionVerb")
					if inputType["questionType"] == "do":
						inputType["globalObjectEx"] = word
						debug(f"@ getInput(): questionType is \"do\", setting globalObjectEx to \"{word}\"")

		if inputType["isQuestion"]:
			if not userInput[-1] == "?":
				userInput += "?"
		
		debug(f"@ getInput(): {userInput=}")
		try:
			if listUserInput[0][len(inputType["questionType"])] == "s":
				debug("@ getInput(): found 's' in the questionType")
				debug("@ getInput(): arranging userInput")
				listUserInput.pop(0)
				listUserInput.insert(0, inputType["questionType"])
				listUserInput.insert(1, "is")
				userInput = " ".join(listUserInput).title()
				debug(f"@ getInput(): final userInput ---\\> {userInput=}")
			
		except IndexError:
			pass

		debug(f"@ getInput(): checking user input for interrogative words")
		debug("@ getInput(): getting subject word")

		inputType["adjectiveWord"] = getFirstAdjective(userInput)
		inputType["subjectWord"] = clean(getSubject(userInput))
		inputType["rawSubjectWord"] = getSubject(userInput).lower()

		debug(f"@ getInput(): adjectiveWord ---\\> {inputType["adjectiveWord"]=}")
		debug(f"@ getInput(): getting subject word branch ---\\> {inputType["subjectWord"]=}")
		debug(f"@ getInput(): getting subject word branch ---\\> {inputType["rawSubjectWord"]=}")

		debug("@ getInput(): checking subject word")
		for word in interrogativeWords:
			# debug(f"@ getInput(): {inputType["subjectWord"]=}")
			if word == inputType["subjectWord"]:
				# debug("@ getInput(): getting predicate nominative")
				predicateNominative = getPredicateNominative(userInput)[::-1]
				# debug(f"@ getInput(): {predicateNominative}")
				if predicateNominative:
					inputType["subjectWord"] = clean(predicateNominative[0])
					inputType["rawSubjectWord"] = predicateNominative[0].lower()
					debug(f"@ getInput(): checking subject word branch ---\\> {inputType["subjectWord"]=}")
					debug(f"@ getInput(): checking subject word branch ---\\> {inputType["rawSubjectWord"]=}")
					# debug(f"@ getInput(): {predicateNominative}")
					if len(predicateNominative) > 1:
						inputType["subjectWordName"] = predicateNominative[1].lower()
						if len(predicateNominative) > 2:
							inputType["subjectWordNameEx"] = predicateNominative[2].lower()
				else:
					debug("@ getInput(): failed getting predicate nominative")
					inputType["subjectWord"] = ""

		debug("@ getInput(): getting direct object")
		for word in personalPronouns:
			if word == inputType["subjectWord"]:
				inputType["subjectWord"] = getDirectObject(userInput)
				debug(f"@ getInput(): getting subject word branch ---\\> {inputType["subjectWord"]=}")
				debug(f"@ getInput(): getting subject word branch ---\\> {inputType["rawSubjectWord"]=}")
				if inputType["subjectWord"] == inputType["questionType"]:
					inputType["globalObjectEx"] = getRootVerb(userInput)
				elif not inputType["subjectWord"]:
					debug("@ getInput(): failed getting direct object")

		if not inputType["subjectWord"]:
			debug("@ getInput(): getting main verb")
			inputType["subjectWord"] = clean(getRootVerb(userInput))
			inputType["rawSubjectWord"] = getRootVerbIndex(userInput).lower()
			debug(f"@ getInput(): getting main branch ---\\> {inputType["subjectWord"]=}")
			debug(f"@ getInput(): getting main branch ---\\> {inputType["rawSubjectWord"]=}")

		inputType["globalObject"] = getGlobalObject(userInput).lower()
		inputType["grammaticalNumber"] = getGrammaticalNumber(userInput)
		inputType["totalWords"] = len(listUserInput)
		debug(f"@ getInput(): getting globalObject branch ---\\> {inputType["globalObject"]=}")

		for iteration in range(len(listUserInput)):
			# debug(f"@ getInput(): {listUserInput[iteration]=}")
			# debug(f"@ getInput(): {inputType["rawSubjectWord"]=}")
			if listUserInput[iteration] == inputType["rawSubjectWord"]:
				inputType["subjectWordIndex"] = iteration

		debug("@ getInput(): checking for surname")
		try:
			if listUserInput[inputType["subjectWordIndex"]+1]:
				predicateNominative = getPredicateNominative(userInput)[::-1]
				# debug(f"@ getInput(): {len(predicateNominative)}")
				if len(predicateNominative) > 1:
					firstPredicate = predicateNominative[0]
					secondPredicate = predicateNominative[1]
					predicateNominative[0] = secondPredicate
					predicateNominative[1] = firstPredicate
					debug(f"@ getInput(): output of getPredicateNominative() ---\\> {predicateNominative=}")
					inputType["subjectWord"] = clean(predicateNominative[1])
					inputType["rawSubjectWord"] = predicateNominative[1].lower()
					# debug(f"@ getInput(): {predicateNominative}")
					inputType["subjectWordName"] = predicateNominative[0].lower()
					if len(predicateNominative) > 2:
						inputType["subjectWordNameEx"] = predicateNominative[2].lower()
				elif len(predicateNominative) == 1:
					debug(f"@ getInput(): output of getPredicateNominative() ---\\> {predicateNominative=}")
					inputType["subjectWord"] = clean(predicateNominative[0])
					inputType["rawSubjectWord"] = predicateNominative[0].lower()
		except IndexError:
			pass

		if not inputType["globalObject"]:
			if inputType["questionType"] == "how":
				inputType["globalObject"] = getObjectOfPreposition(userInput)
			else:
				debug("@ getInput(): getting direct to globalObject")
				inputType["globalObject"] = getDirectObjectEx(userInput).lower()
				debug(f"@ getInput(): output of getDirectObjectEx() ---\\> {getDirectObjectEx(userInput)=}")
				for word in interrogativeWords:
					if word == inputType["globalObject"]:
						inputType["globalObject"] = ""
				if not inputType["globalObject"]:
					debug("@ getInput(): failed getDirectObjectEx() trying again getProperNoun()")
					inputType["globalObject"] = getProperNoun(userInput)
					debug(f"@ getInput(): getProperNoun() to globalObject ---\\> {inputType["globalObject"]=}")

		if inputType["rawSubjectWord"] == inputType["globalObject"]:
			debug("@ getInput(): re declaring globalObject")
			inputType["globalObject"] = getFirstPrepositionalObject(userInput).lower()
			debug(f"@ getInput(): getFirstPrepositionalObject() to globalObject ---\\> {inputType["globalObject"]=}")
			if not inputType["globalObject"] == getNestedPrepositionalObject(userInput):
				inputType["globalObjectEx"] = getNestedPrepositionalObject(userInput)

		if inputType["rawSubjectWord"] == inputType["globalObject"]:
			debug("@ getInput(): subjectWord and globalObject is the same, redefining subjectWord")
			inputType["subjectWord"] = getPredicateNominative(userInput)

		if inputType["modalVerb"]:
			if not inputType["questionType"] or inputType["questionType"] == "what":
				debug("@ getInput(): found modalVerb, defining globalObject")
				inputType["globalObject"] = getRootVerb(userInput)
				debug(f"@ getInput(): getRootVerb() to globalObject ---\\> {inputType["globalObject"]=}")
				debug("@ getInput(): trying to get a direct object")
				if getDirectObject(userInput):
					inputType["globalObjectEx"] = getDirectObject(userInput)
				else:
					debug("@ getInput(): failed to get direct object")

		if inputType["adjectiveWord"] == inputType["rawSubjectWord"]:
			inputType["adjectiveWord"] = getFirstAdverb(userInput)

		if inputType["subjectWordName"] == inputType["globalObject"]:
			inputType["globalObject"] = getProperNoun(userInput)
			debug(f"@ getInput(): getProperNoun() to globalObject ---\\> {inputType["globalObject"]=}")
			debug("@ getInput(): checking if globalObject and subjectWordName are still the same")
			if inputType["subjectWordName"] == inputType["globalObject"]:
				debug("@ getInput(): globalObject and subjectWordName are still the same, clearing globalObject")
				inputType["globalObject"] = ""

			if inputType["globalObject"] == inputType["subjectWord"]:
				inputType["globalObject"] = ""

		inputType["adjectiveWordEx"] = getFirstAdverb(userInput)
		if inputType["adjectiveWord"] == inputType["adjectiveWordEx"]:
			inputType["adjectiveWordEx"] = ""

		if inputType["questionType"] == "do":
			inputType["subjectWordName"] = getMainVerb(userInput)

		if not inputType["isQuestion"] and inputType["totalWords"] < 3:
			inputType["rootWord"] = getRootWord(userInput)

		debug(f"@ getInput(): {inputType['isQuestion']=}")
		debug(f"@ getInput(): {inputType['questionType']=}")
		debug(f"@ getInput(): {inputType["interrogativeWordsCount"]=}")
		debug(f"@ getInput(): {inputType["subjectWord"]=}")
		debug(f"@ getInput(): {inputType["subjectWordIndex"]=}")
		debug(f"@ getInput(): {inputType["subjectWordName"]=}")
		debug(f"@ getInput(): {inputType["subjectWordNameEx"]=}")
		debug(f"@ getInput(): {inputType["grammaticalNumber"]=}")
		debug(f"@ getInput(): {inputType["rawSubjectWord"]=}")
		debug(f"@ getInput(): {inputType["rootWord"]=}")
		debug(f"@ getInput(): {inputType["globalObject"]=}")
		debug(f"@ getInput(): {inputType["globalObjectEx"]=}")
		debug(f"@ getInput(): {inputType["modalVerb"]=}")
		debug(f"@ getInput(): {inputType["adjectiveWord"]=}")
		debug(f"@ getInput(): {inputType["adjectiveWordEx"]=}")
		debug(f"@ getInput(): {inputType["adverbTime"]=}")
		debug(f"@ getInput(): {inputType["totalWords"]=}")

		return inputType, listUserInput

	except KeyboardInterrupt:
		debug("@ getInput(): executing exit()")
		debug("@ getInput(): exiting program")
		exit()

def processInput(typeInput: dict, inputUser: list) -> None:
	debug(f"@ processInput(): checking the number of interrogative words")

	# NOTE:
	# Add capability to deal with greetings and other type of questions that
	# does not start with an interogative word.

	# debug(f"branch #2.2 ---\\> {possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWordName"]]}")
	if typeInput["interrogativeWordsCount"] > 1:
		talkBot(selectRandom(overloadQuestionErrorResponses))

	else:
		try:
			if typeInput["questionType"]:
				debug("@ processInput(): declaring response")

				if typeInput["questionType"] == "where" and typeInput["globalObject"]:
					if typeInput["adjectiveWord"]:
						debug("@ processInput(): branch #1.0")
						debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWord"]}][{typeInput["globalObject"]}]")
						response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]][typeInput["globalObject"]]

				elif typeInput["questionType"] == "how" and typeInput["globalObject"]:
					if typeInput["subjectWordName"]:
						debug("@ processInput(): branch #2.0")
						debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["globalObject"]}][{typeInput["rawSubjectWord"]}][{typeInput["subjectWordName"]}]")
						response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]][typeInput["rawSubjectWord"]][typeInput["subjectWordName"]]
					else:
						if typeInput["adverbTime"]:
							debug("@ processInput(): branch #2.01")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["globalObject"]}][{typeInput["adverbTime"]}]")
							response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]][typeInput["adverbTime"]]
						else:
							debug("@ processInput(): branch #2.02")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["globalObject"]}][{typeInput["globalObject"]}]")
							response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]][typeInput["globalObject"]]

				elif typeInput["modalVerb"]:
					if typeInput["questionType"] == "what":
						debug("@ processInput(): branch #3.0")
						debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["modalVerb"]}][{typeInput["subjectWord"]}][{typeInput["globalObject"]}]")
						response = possibleResponses[typeInput["questionType"]][typeInput["modalVerb"]][typeInput["subjectWord"]][typeInput["globalObject"]]

				elif typeInput["subjectWordName"]:
					if typeInput["subjectWordNameEx"]:
						try:
							debug("@ processInput(): branch #4.0")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["subjectWord"]}][{typeInput["subjectWordName"]}][{typeInput["subjectWordNameEx"]}]")
							response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWordName"]][typeInput["subjectWordNameEx"]]

						except KeyError:
							if typeInput["adjectiveWordEx"]:
								debug("@ processInput(): branch #4.1")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWordEx"]}][{typeInput["subjectWordName"]}][{typeInput["subjectWord"]}][{typeInput["subjectWordNameEx"]}]")
							else:
								debug("@ processInput(): branch #4.2")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["subjectWordName"]}][{typeInput["subjectWord"]}][{typeInput["subjectWordNameEx"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWordName"]][typeInput["subjectWord"]][typeInput["subjectWordNameEx"]]
					else:
						if typeInput["adjectiveWord"]:
							debug("@ processInput(): branch #5.0")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWord"]}][{typeInput["rawSubjectWord"]}][{typeInput["subjectWordName"]}]")
							response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]][typeInput["rawSubjectWord"]][typeInput["subjectWordName"]]
						else:
							if typeInput["globalObject"]:
								debug("@ processInput(): branch #5.01")
								debug("@ processInput(): restructuring response")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["subjectWord"]}][{typeInput["subjectWordName"]}][{typeInput["globalObject"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWordName"]][typeInput["globalObject"]]
							else:
								debug("@ processInput(): branch #5.02")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["subjectWord"]}][{typeInput["subjectWordName"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWordName"]]

				elif typeInput["subjectWord"]:
					if typeInput["globalObject"]:
						try:
							if typeInput["globalObjectEx"]:
								debug("@ processInput(): branch #6.0")
								debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["rawSubjectWord"]}][{typeInput["globalObjectEx"]}][{typeInput["globalObject"]}]")
								response = possibleResponses[typeInput['questionType']][typeInput["rawSubjectWord"]][typeInput["globalObjectEx"]][typeInput["globalObject"]]
								if typeInput["questionType"] != typeInput["subjectWord"]:
									debug("@ processInput(): branch #6.01")
									debug("@ processInput(): questionType and subjectWord are not the same, redefining response")
									debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}][{typeInput["globalObject"]}][{typeInput["globalObjectEx"]}]")
									response = possibleResponses[typeInput['questionType']][typeInput["subjectWord"]][typeInput["globalObject"]][typeInput["globalObjectEx"]]
						except KeyError:
							if typeInput["adjectiveWord"]:
								debug("@ processInput(): branch #6.02")
								debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["rawSubjectWord"]}][{typeInput["globalObject"]}][{typeInput["adjectiveWord"]}]")
								response = possibleResponses[typeInput['questionType']][typeInput["rawSubjectWord"]][typeInput["globalObject"]][typeInput["adjectiveWord"]]

						else:
							if typeInput["questionType"] == "what" and typeInput["globalObject"] and typeInput["rawSubjectWord"]:
								if typeInput["adjectiveWord"]:
									if typeInput["adjectiveWordEx"]:
										debug("@ processInput(): branch #7.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWordEx"]}][{typeInput["adjectiveWord"]}][{typeInput["globalObject"]}][{typeInput["rawSubjectWord"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput['adjectiveWordEx']][typeInput["adjectiveWord"]][typeInput["globalObject"]][typeInput["rawSubjectWord"]]
									else:
										debug("@ processInput(): branch #8.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWord"]}][{typeInput["globalObject"]}][{typeInput["rawSubjectWord"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]][typeInput["globalObject"]][typeInput["rawSubjectWord"]]
								else:
									if typeInput["adverbTime"]:
										debug("@ processInput(): branch #9.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["globalObject"]}][{typeInput["adverbTime"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]][typeInput["adverbTime"]]
									else:
										debug("@ processInput(): branch #10.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["globalObject"]}][{typeInput["rawSubjectWord"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]][typeInput["rawSubjectWord"]]
										debug(f"@ processInput(): datatype of response ---\\> {type(response)}")
							else:
								if typeInput["adjectiveWord"]:
									try:
										debug("@ processInput(): branch #11.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}][{typeInput["adjectiveWord"]}][{typeInput["globalObject"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["adjectiveWord"]][typeInput["globalObject"]]
									except KeyError:
										debug("@ processInput(): branch #11.1")
										debug("@ processInput(): restructuring response")
										debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["adjectiveWord"]}][{typeInput["globalObject"]}][{typeInput["subjectWord"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]][typeInput["globalObject"]][typeInput["subjectWord"]]
								else:
									try:
										debug("@ processInput(): branch #12.0")
										debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["rawSubjectWord"]}][{typeInput["globalObject"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["rawSubjectWord"]][typeInput["globalObject"]]
										debug(f"@ processInput(): datatype of response ---\\> {type(response)}")
										if type(response) == dict:
											debug("@ processInput(): branch #12.01")
											debug("@ processInput(): response is dictionary, redefining response")
											debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}][{typeInput["globalObject"]}][{typeInput["globalObject"]}]")
											response = possibleResponses[typeInput['questionType']][typeInput["subjectWord"]][typeInput["globalObject"]][typeInput["globalObject"]]
									except:
										debug("@ processInput(): branch #12.1")
										debug("@ processInput(): response is None, redefining response")
										debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}][{typeInput["globalObject"]}]")
										response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["globalObject"]]

					else:
						if typeInput["adjectiveWord"]:
							try:
								debug("@ processInput(): branch #13.0")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWord"]}][{typeInput["rawSubjectWord"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]][typeInput["rawSubjectWord"]]
							except KeyError:
								debug("@ processInput(): branch #13.01")
								debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["subjectWord"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWord"]]
						else:
							debug("@ processInput(): branch #14.0")
							debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["rawSubjectWord"]}]")
							response = possibleResponses[typeInput["questionType"]][typeInput["rawSubjectWord"]]
							debug(f"@ processInput(): datatype of response ---\\> {type(response)}")
							if type(response) == dict:
								debug("@ processInput(): branch #14.01")
								debug("@ processInput(): response is dictionary, redefining response")
								debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}][{typeInput["subjectWord"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]][typeInput["subjectWord"]]
							elif not response:
								debug("@ processInput(): branch #14.02")
								debug("@ processInput(): response is None, redefining response")
								debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["subjectWord"]}]")
								response = possibleResponses[typeInput["questionType"]][typeInput["subjectWord"]]

				elif typeInput["questionType"] and typeInput["adjectiveWord"]:
					debug("@ processInput(): branch #19.0")
					debug("@ processInput(): only questionType and adjectiveWord found, defining response")
					debug(f"@ processInput(): response = possibleResponses[{typeInput["questionType"]}][{typeInput["adjectiveWord"]}]")
					response = possibleResponses[typeInput["questionType"]][typeInput["adjectiveWord"]]

				else:
					if typeInput["globalObject"]:
						debug("@ processInput(): branch #15.0")
						debug(f"@ processInput(): response = possibleResponses[{typeInput['questionType']}][{typeInput["globalObject"]}]")
						response = possibleResponses[typeInput["questionType"]][typeInput["globalObject"]]


			elif typeInput["modalVerb"]:
				if typeInput["globalObject"]:
					if not typeInput["globalObjectEx"]:
						debug("@ processInput(): branch #16.0")
						debug(f"@ processInput(): response = possibleResponses[{typeInput["modalVerb"]}][{typeInput["rawSubjectWord"]}][{typeInput["globalObject"]}]")
						response = possibleResponses[typeInput["modalVerb"]][typeInput["rawSubjectWord"]][typeInput["globalObject"]]
					else:
						if typeInput["adjectiveWord"]:
							debug("@ processInput(): branch #16.01")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["modalVerb"]}][{typeInput["rawSubjectWord"]}][{typeInput["globalObject"]}][{typeInput["adjectiveWord"]}][{typeInput["globalObjectEx"]}]")
							response = possibleResponses[typeInput["modalVerb"]][typeInput["rawSubjectWord"]][typeInput["globalObject"]][typeInput["adjectiveWord"]][typeInput["globalObjectEx"]]
						else:
							debug("@ processInput(): branch #16.02")
							debug(f"@ processInput(): response = possibleResponses[{typeInput["modalVerb"]}][{typeInput["rawSubjectWord"]}][{typeInput["globalObject"]}][{typeInput["globalObjectEx"]}]")
							response = possibleResponses[typeInput["modalVerb"]][typeInput["rawSubjectWord"]][typeInput["globalObject"]][typeInput["globalObjectEx"]]

			elif typeInput["subjectWord"] and typeInput["globalObject"]:
				debug("@ processInput(): checking for adjectiveWord")
				if typeInput["adjectiveWord"]:
					debug("@ processInput(): branch #17.0")
					debug("@ processInput(): found an adjective")
					debug(f"@ processInput(): response = possibleResponses[{typeInput["subjectWord"]}][{typeInput["globalObject"]}][{typeInput["adjectiveWord"]}]")
					response = possibleResponses[typeInput["subjectWord"]][typeInput["globalObject"]][typeInput["adjectiveWord"]]
				else:
					debug("@ processInput(): branch #18.0")
					debug("@ processInput(): no adjective found")
					debug(f"@ processInput(): response = possibleResponses[{typeInput["subjectWord"]}][{typeInput["globalObject"]}]")
					response = possibleResponses[typeInput["subjectWord"]][typeInput["globalObject"]]
					debug(f"@ processInput(): datatype of response ---\\> {type(response)}")
					if type(response) == dict:
						debug("@ processInput(): branch #18.01")
						debug("@ processInput(): response is dictionary, redefining response")
						debug(f"@ processInput(): response = possibleResponses[{typeInput["subjectWord"]}][{typeInput["globalObject"]}][{typeInput["globalObject"]}]")
						response = possibleResponses[typeInput["subjectWord"]][typeInput["globalObject"]][typeInput["globalObject"]]

			elif typeInput["rootWord"]:
				if typeInput["adjectiveWord"]:
					debug("@ processInput(): branch 19.0")
					debug(f"@ processInput(): response = possibleResponses[{typeInput["rootWord"]}][{typeInput["adjectiveWord"]}]")
					response = possibleResponses[typeInput["rootWord"]][typeInput["adjectiveWord"]]
				else:
					debug("@ processInput(): branch 19.01")
					debug("@ processInput(): input is a greeting, getting response from introGreet()")
					debug("@ processInput(): response = introGreet()")
					response = introGreet()

			if type(response) == tuple:
				debug("@ processInput(): response is tuple")
				debug("@ processInput(): chatbot replying")
				talkBot(selectRandom(response))
			else:
				debug("@ processInput(): chatbot replying")
				talkBot(response)

		except KeyError:
			if not typeInput["questionType"]:
				debug("@ processInput(): raising inputErrorResponses")
				talkBot(selectRandom(inputErrorResponses))
			else:
				talkBot(selectRandom(questionErrorResponses[typeInput["questionType"]]))

def initiateConversation() -> None:
	while True:
		try:
			debug(f"@ initiateConversation(): executing getInput()")
			typeInput, listUserInput = getInput()
			debug(f"@ initiateConversation(): executing processInput()")
			processInput(typeInput, listUserInput)
		
		except TypeError:
			talkBot(selectRandom(inputErrorResponses))
			initiateConversation()

		except UnboundLocalError:
			talkBot(selectRandom(inputErrorResponses))
			initiateConversation()


def main() -> None:
	debug("@ main(): executing printBanner()")
	printBanner()
	debug("@ main(): executing introGreet()")
	talkBot(introGreet())
	debug("@ main(): executing initiateConversation()")
	initiateConversation()

""" END: FUNCTIONS """

""" ENTRY POINT: START OF THE PROGRAM """

if __name__ == '__main__':
	parser = argparse.ArgumentParser("A simple chatbot designed to assist with a medium range of questions related to Liceo De Cagayan University.")
	parser.add_argument("--debug", action="store_true", help="Enable debugging output")
	arguments = parser.parse_args()

	if arguments.debug:
		debugging = True
		
	debug("@ entry_point: starting program")
	debug("@ entry_point: executing main()")
	main()
